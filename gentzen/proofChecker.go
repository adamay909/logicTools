package gentzen

import (
	"errors"
	"strconv"
	"strings"
)

//arugment lines are given as semicolon separated lists:
//datum;succedent;lines used;inference rule
//
//inference rules are given by:ni,ne,ki,ke,di,de,ci,ce,a
//

type argLine struct {
	seq   sequent
	lines []int
	inf   string
}

const (
	ni  = "ni"
	ne  = "ne"
	ki  = "ki"
	ke  = "ke"
	di  = "di"
	de  = "de"
	ci  = "ci"
	ce  = "ce"
	a   = "a"
	m   = "m"
	ui  = "ui"
	ue  = "ue"
	ei  = "ei"
	ee  = "ee"
	ii  = "=i"
	ie  = "=e"
	li  = `li` //use l and m for necessity and possibility
	le  = `le`
	mi  = `mi`
	me  = `me`
	mli = `mli`
	pli = `pli`
	tli = `tli`
	mme = "mme"
	sc  = "sc"
	sl  = "sl"
)

var strictCheck bool

/*
CheckDeriv checks the derivation given by lines.
Each line represents a sequent followed by an annotation
consisting of line references and inference rule/theorem name.
The elements of each line must be semicolon separated. You may use
spaces and tabs for readability. The available rules are:

ne: negation elimination

ni: negation introduction

de: disjunction elimination

di: disjunction introduction

ke: conjunction elimination

ki: conjunction introduction

ce: conditional elimination

ci: conditional introduction

ue: universal quantifier elimination

ui: universal quantifier introduction

ei: existential quantifier introduction

ee: existential quantifier elimination

see the textbook on how the rules work.
*/
func CheckDeriv(lines []string, offset int) bool {

	return checkDerivation(lines, offset)

}

// printDeriv prints the derivation given by lines
// as latex formatted derivation.
func printDeriv(lines []string, offset int) (out string) {

	out = out + `\begin{argumentN}[` + strconv.Itoa(offset) + "]\n"

	out = out + `%generated by gentzen` + "\n\n"

	for i := range lines {

		out = out + printDerivline(lines[i], O_Latex)
	}

	out = out + `\end{argumentN}` + "\n\n"

	return out
}

// PrintDerivation prints the derivation given by lines
// in the format specified by mode.
func PrintDerivation(lines []string, offset int, m PrintMode) (out string) {

	if m == O_Latex {
		return printDeriv(lines, offset)
	}

	for i := range lines {

		out = out + strconv.Itoa(i+offset) + `. ` + printDerivline(lines[i], m) + "\n"
	}

	return out
}

func checkDerivation(lines []string, offset int) bool {

	Debug("start derivation checking**********")
	deriv, ok := getDerivation(lines, offset)
	if !ok {
		return false
	}
	Debug("length of derivation: ", len(deriv))
	Debug("offset: ", offset)

	if !lineRefsOK(deriv, offset) {
		return false
	}

	for n := range deriv {
		logger.SetPrefix("line " + strconv.Itoa(n+1) + ": ")
		Debug("check line no. ", n+1)
		if !checkStep(getDerivTree(deriv, n)) {
			Debug("check fail")
			ok = false
		}
		Debug("------------------------")

	}
	Debug("finished derivation checking**********")
	return ok
}

func isSequent(c string) (err error) {

	fields := strings.Split(c, ";")

	if len(fields) != 2 {
		err = errors.New("Not a sequent")
		return err
	}

	//check datum is ok
	datums := strings.Split(fields[0], ",")
	for _, d := range datums {
		if len(d) < 1 {
			continue
		}
		if isFormulaSet(d) {
			continue
		}

		_, err := ParseStrict(d, !allowGreekUpper)

		if err != nil {
			return err
		}
	}

	//check succedent is ok

	if len(fields[1]) < 1 {
		err = errors.New("Not a sequent")
		return
	}
	if containsFormulaSet(fields[1]) {
		err = errors.New("Cannot have place holders for sets of formulas in succedent")
		return
	}
	_, err = ParseStrict(fields[1], !allowGreekUpper)
	if err != nil {
		return
	}
	return
}

func parseDerivline(s string) (al argLine, err error) {

	s = strings.ReplaceAll(s, " ", "")
	s = strings.ReplaceAll(s, "\t", "")

	fields := strings.Split(s, ";")
	//check we have enough fields
	if len(fields) < 3 {
		err = errors.New("you need: datum, succedent and at least one of: line references, inference rule")
		return
	}

	err = isSequent(strings.Join(fields[:2], ";"))
	if err != nil {
		return
	}

	al.seq.d = datum(strings.TrimSpace(fields[0]))
	al.seq.s = plshFormula(strings.TrimSpace(fields[1]))

	if len(fields) == 4 {
		al.inf = fields[3]
	}

	if len(strings.TrimSpace(fields[2])) == 0 {
		err = errors.New("you need: datum, succedent and at least one of: line references, inference rule")
		return
	}

	ln := strings.Split(fields[2], ",")

	var i int
	var e string

	for i = 0; i < len(ln); i++ {
		e = ln[i]
		n, err := strconv.Atoi(e)
		if err != nil {
			break
		}
		al.lines = append(al.lines, n)
	}

	al.inf = "rewrite"

	if len(ln[i:]) > 0 {
		al.inf = strings.TrimSpace(ln[i])
	}

	if len(ln[i:]) > 1 {
		err = errors.New("You must have no more than one inference rule")
		return
	}

	return
}

func hasGreek(s string) bool {
	if !oPL {
		return strings.Contains(s, `\`)
	}
	r := []rune(s)

	for i := range r {
		for _, e := range greekUpperCaseLetters {
			if strings.HasPrefix(string(r[i:]), e) {
				return true
			}
		}
	}
	return false
}

func printDerivline(s string, m PrintMode) string {

	al, _ := parseDerivline(s)

	return printArgline(al, m)

}

func printArgline(al argLine, m PrintMode) string {

	datumstring := al.printDatum(m)

	succstring := Parse(al.seq.succedent().String(), !allowGreekUpper).StringF(m)

	annotation := al.printAnnotation(m)

	var resp string

	if m == O_Latex {
		resp = `\ai{` + datumstring + `}{` + succstring + `}{` + annotation + `}` + "\n\n"
		return resp
	}
	if m == O_ProofChecker {
		resp = convSubscript(datumstring) + `⊢` + convSubscript(succstring) + `...` + convSubscript(annotation)
	}

	if m == O_PlainText {
		resp = datumstring + ` ⊢ ` + succstring + `...` + annotation
	}

	if m == O_PlainASCII || m == O_English || m == O_Polish {
		resp = datumstring + ` : ` + succstring + `...` + annotation
	}
	return resp
}

func convSubscript(s string) (o string) {

	r := []rune(s)

	for k := 0; k < len(r); k++ {
		if r[k] == '_' {
			o = o + `<sub>` + string(r[k+1]) + `</sub>`
			k++
		} else {
			o = o + string(r[k])
		}
	}
	return o
}

func (al argLine) printDatum(m PrintMode) string {

	datumstring := ""

	if len(al.seq.d) != 0 {

		datums := al.seq.datumSlice()
		for k, d := range datums {
			Debug("datum ", k, ": ", d)

			n, err := ParseStrict(string(d), allowGreekUpper)
			if err != nil {
				logger.Print("something wrong with datum")
				return ""
			}

			datumstring = datumstring + n.StringF(m) + `, `
		}
		datumstring = strings.TrimRight(datumstring, ", ")
	}

	return datumstring

}

func (al argLine) printAnnotation(m PrintMode) string {

	annotation := ""
	if len(al.lines) > 0 {
		for _, i := range al.lines {
			annotation = annotation + strconv.Itoa(i) + `,`
		}
	}

	annotation = annotation + symb(al.inf, m)

	annotation = strings.TrimRight(annotation, ",")

	return annotation

}

func symb(s string, m PrintMode) string {

	if m == O_ProofChecker {
		m = O_PlainText
	}

	if m == O_PlainASCII || m == O_English || m == O_Polish {
		m = O_PlainText
	}

	s = strings.TrimSpace(s)
	for _, i := range infRules {
		if i[0] == s {
			return i[m]
		}
	}
	return s
}

func runeOf[str ~string](s str, m PrintMode) string {
	var n int
	if m == O_Latex {
		n = 1
	} else {
		n = 2
	}
	for _, e := range greekLCBindings {
		if e[1] == string(s) {
			return e[n]
		}
	}
	for _, e := range greekUCBindings {
		if e[1] == string(s) {
			return e[n]
		}
	}
	return string(s)
}

func _asciize(s string, m PrintMode) string {

	n := 0

	found := false

	resp := ""

	for _, r := range s {

		found = false
		for _, e := range greekLCBindings {
			if firstrune(e[2]) == r {
				resp = resp + e[n]
				found = true
				break
			}
		}
		if found {
			continue
		}

		for _, e := range greekUCBindings {
			if firstrune(e[2]) == r {
				resp = resp + e[n]
				found = true
				break
			}
		}
		if found {
			continue
		}

		resp = resp + string(r)
	}

	return resp

}

func firstrune(s string) rune {

	for _, e := range s {
		return e
	}

	return 0
}

func splitSubscript(s string) (m, sub string) {
	m = s
	sub = ""
	if i := strings.Index(s, "_"); i > 0 {
		m = s[:i]
		sub = s[i:]
	}

	return
}

func isFormulaSet(s string) bool {

	Debug("checking ", s)

	tk, err := tokenize(s, allowGreekUpper, !allowSpecial)

	if err != nil {
		return false
	}

	if len(tk) != 1 {
		return false
	}

	ch, err := getFirstChar(tk[0].str, allowSubscr, !allowNumeral, allowGreekUpper, allowIdentity, !allowSpecial)

	if err != nil {
		return false
	}

	chb := strings.Split(ch, "_")[0]
	if isGreekUpper(chb) {
		return true
	}

	return false

}

func containsFormulaSet(s string) bool {

	r := []rune(s)

	for _, e := range r {
		if isFormulaSet(string(e)) {
			return true
		}
	}
	return false
}
