package gentzen

import (
	"strings"
)

type tablNode struct {
	tkstr     tokenStr
	str       string
	child     []*tablNode
	parent    *tablNode
	processed bool
	closed    bool
	visited   bool
	full      bool
}

func generateTableaux(s string, closeOff bool) *tablNode {

	tk, err := tokenize(s, !allowGreekUpper, !allowSpecial)

	if err != nil {
		panic("not a wff")
	}

	n := newtablnode(tk)

	done := false

	for nl := n.linearize(); !done; nl = n.linearize() {

		done = true

		for _, e := range nl {
			if !e.visited && !e.closed {
				done = false
			}
			e.growTree(closeOff)
		}
	}

	return n
}

func generateNormalTableaux(s string) *tablNode {

	return generateTableaux(s, true)

}

func generateFullTableaux(s string) *tablNode {

	return generateTableaux(s, false)
}

func isTautologyTableaux(s string) bool {

	s = "N" + s

	tb := generateNormalTableaux(s)

	return tb.isInconsistent()

}

func (n *tablNode) isInconsistent() bool {

	ln := n.top().linearize()

	for _, e := range ln {

		if len(e.child) != 0 {
			continue
		}

		if e.closed {
			continue
		}

		for p := e; p != nil; p = p.parent {

			target := p.tkstr.negate().String()

			for c := p.parent; c != nil; c = c.parent {
				if c.str == target {
					e.closed = true
					break
				}
			}

			if e.closed {
				break
			}

			if p.tkstr[0].tokenType == tNeg {

				target = p.tkstr[1:].String()

				for c := p.parent; c != nil; c = c.parent {
					if c.str == target {
						e.closed = true
						break
					}
				}
			}

		}
		if !e.closed {
			return false
		}
	}
	return true
}

func (n *tablNode) checkIfClosed() {

	target := n.tkstr.negate().String()

	for c := n.parent; c != nil; c = c.parent {
		if c.str == target {
			n.closed = true
			return
		}
	}

	if n.tkstr[0].tokenType == tNeg {
		target = n.tkstr[1:].String()

		for c := n.parent; c != nil; c = c.parent {
			if c.str == target {
				n.closed = true
				return
			}
		}
	}
	return
}

func newtablnode(tk tokenStr) *tablNode {

	n := new(tablNode)

	n.tkstr = make(tokenStr, 0, len(tk))

	n.tkstr = append(n.tkstr, tk...)

	n.str = n.tkstr.String()

	return n
}

func (n *tablNode) top() *tablNode {

	for e := n; e != nil; e = e.parent {
		if e.parent == nil {
			return e
		}
	}
	return n
}

func (n *tablNode) linearize() []*tablNode {

	var resp []*tablNode

	var walk func(*tablNode)

	walk = func(e *tablNode) {

		resp = append(resp, e)

		for _, c := range e.child {

			walk(c)

		}

	}

	walk(n)

	return resp

}

func (n *tablNode) growTree(closeOff bool) {

	if n.closed {
		n.visited = true
	}

	if n.visited {
		return
	}

	n.visited = true

	subs := n.tkstr.subFormulas()

	switch n.tkstr[0].tokenType {

	case tConj:

		n.addChild(closeOff, subs[0])
		n.addChild(closeOff, subs[1])

	case tDisj:

		n.addChild(closeOff, subs[0], subs[1])

	case tCond:

		n.addChild(closeOff, subs[0].negate(), subs[1])

	case tNeg:

		switch n.tkstr[1].tokenType {

		case tNeg:

			n.addChild(closeOff, n.tkstr[2:])

			//NKpq => ANpNq
		case tConj:

			subs2 := subs[0].subFormulas()

			n.addChild(closeOff, subs2[0].negate(), subs2[1].negate())

			//NApq => KNpNq
		case tDisj:

			subs2 := subs[0].subFormulas()

			n.addChild(closeOff, subs2[0].negate())
			n.addChild(closeOff, subs2[1].negate())

			//NCpq =>KpNq
		case tCond:

			subs2 := subs[0].subFormulas()

			n.addChild(closeOff, subs2[0])
			n.addChild(closeOff, subs2[1].negate())

		}
	default:
		n.full = true
	}
}

func (n *tablNode) addChild(closeOff bool, c ...tokenStr) {

	gp := n.linearize()

	for _, e := range gp {
		if len(e.child) == 0 {

			for _, ch := range c {
				nc := newtablnode(ch)
				e.child = append(e.child, nc)
				nc.parent = e
				if closeOff {
					nc.checkIfClosed()
				}
			}
		}
	}
}

// PrintSemanticTableau returns the LaTeX code for printing the
// semantic tableau of s in tree form. A closed branch terminates
// with a circle with an x inside.
func PrintSemanticTableau(s string) string {

	t := generateTableaux(s, true)

	w := new(strings.Builder)

	var lt func(n *tablNode) string

	lt = func(n *tablNode) (r string) {

		r = r + `[ \p{` + Parse(n.str, !allowGreekUpper).StringF(O_Latex) + `} ` + "\n"

		if n.closed {
			r = r + `[ \p{\otimes} ]` + "\n"
			r = r + ` ] ` + "\n" // !{\qbalance} `
			return
		}

		for _, k := range n.child {

			r = r + lt(k)
		}

		r = r + ` ] ` + "\n" // !{\qbalance} `

		return r
	}

	w.WriteString(`\begin{forest}` + "\n")
	w.WriteString(`%semantic tableaux of:` + "\n% " + s + "\n")
	w.WriteString(`%generated by gentzen` + "\n")
	w.WriteString(`DATA`)
	w.WriteString(`\end{forest}` + "\n\n")
	templ := w.String()
	w.Reset()

	return strings.ReplaceAll(templ, `DATA`, lt(t))

}
