package gentzen

import (
	"fmt"
	"strconv"
	"strings"
)

func PrintSemanticTableaux(n *Node, annot bool, verbose bool) string {

	t := semanticTableau(n, verbose)

	t.pruneTableau()
	var lt func(n *tablNode) string

	lt = func(n *tablNode) (r string) {

		if len(n.ancestor) > 0 {
			if n.ancestor[0].nodeIsClosed() {
				return
			}
		}
		if n.nodeIsClosed() {

			r = `[ \p{\nullset} ` + "\n"

		} else {

			r = `[ \p{` + Parse(n.formula.String()).StringLatex() + `} `
			if annot {
				r = r + `\\\tiny{\p{` + n.annotation() + `}}\normalsize`
			}
			r = r + "\n"

		}
		for k := 0; k < len(n.child); k++ {

			r = r + lt(n.child[k])
		}

		r = r + ` ] ` + "\n" // !{\qbalance} `

		return r
	}
	templ := `\begin{forest}%generated by gentzen
for tree ={align=center}
DATA\end{forest}

`

	if annot {
		templ = `\renewcommand{\baselinestretch}{0.5}
\begin{forest}%generated by gentzen
for tree ={align=center}
DATA\end{forest}
\renewcommand{\baselinestretch}{1.0}
`
	}
	return strings.ReplaceAll(templ, `DATA`, lt(t))

}

func (n *tablNode) pruneTableau() {
	t := flattenTableaux(n)

	for _, e := range t {
		if e.isClosed() {
			e.child = nil
			x := e.mkchild()
			x.setClosed()
		}
	}

}

func semanticTableau(n *Node, verbose bool) *tablNode {

	resetSkolem()
	r := new(tablNode)
	r.setBase(r)
	r.setRule("assumption")
	r.formula = n
	r.setUnhandled()
	growSemanticTab(r, verbose)
	return r
}

func (n *tablNode) nodeIsClosed() bool {
	if n.closed {
		return true
	}
	return false
}

func flattenTableaux(n *tablNode) []*tablNode {

	var gs func(n *tablNode, list []*tablNode) []*tablNode

	gs = func(n *tablNode, list []*tablNode) []*tablNode {

		list = append(list, n)

		/**	if n.isBasic() {
					return list
				}
		**/
		for i := 0; i < len(n.child); i++ {
			list = gs(n.child[i], list)
		}

		return list
	}

	var list []*tablNode

	return gs(n, list)
}

func quantifierCount(n *Node) int {

	r := 0

	for _, e := range getSubnodes(n) {
		if e.IsQuantifier() {
			r++
		}
	}
	return r

}

var skcounter = 0

func resetSkolem() {
	skcounter = 0
}

func getSKcounter() int {
	return skcounter
}

func nextSkolem() string {

	skcounter++
	return `k_{` + strconv.Itoa(skcounter) + `}`
}

func growSemanticTab(n *tablNode, verbose bool) {

	verbose = false
	counter := 0

	if oPL {
		f1 := n.formula.String()
		n.addChild(Parse(f1).NormalizeVars(), n, `\textrm{normalize variables names}`)
		n.setHandled()

		cr := n.child[0]

		fn := Parse(cr.formula.String())
		for !fn.isPrenex() {

			if !verbose {
				fn = fn.Prenex()
			}
			fn = fn.PrenexOneStep()

			cr.addChild(fn, cr, "Prenex")
			cr.setHandled()
			cr = cr.child[0]

		}

		for _, ff := range instantiationSeries(cr.formula) {
			cr.addChild(Parse(ff), cr, "AXX")
			if cr.formula.IsQuantifier() {
				cr.setHandled()
			}
			cr = cr.child[0]
		}
	}

	for !n.allHandled() {

		//**************
		//circuit breaker
		//just in case :)
		counter++
		if counter > 1000 {
			for _, e := range flattenTableaux(n) {
				if e.growthpoint() {
					e.rule = e.rule + "...BREAK"
				}
			}
			break
		}
		//*************

		tflat := flattenTableaux(n)

		for _, e := range tflat {
			if e.handled {
				continue
			}

			eflat := flattenTableaux(e)
			f := e.formula

			if f.IsAtomic() {
				e.setHandled()
				break
			}

			if f.IsNegation() {

				if f.Child1Must().IsAtomic() {
					e.setHandled()
					break
				}
				if f.Child1Must().IsNegation() {
					for _, e2 := range eflat {
						if !e2.growthpoint() {
							continue
						}
						e2.addChild(f.Child1Must().Child1Must(), e, "A1")
					}
					e.setHandled()
					break
				}
				if f.Child1Must().IsDisjunction() {
					for _, e2 := range eflat {
						if !e2.growthpoint() {
							continue
						}
						n1 := f.Child1Must().Child1Must()
						n2 := f.Child1Must().Child2Must()
						e2.addConj(Negate(n1), Negate(n2), e, "A3")
					}
					e.setHandled()
					break
				}

				if f.Child1Must().IsConditional() {
					for _, e2 := range eflat {
						if !e2.growthpoint() {
							continue
						}
						n1 := f.Child1Must().Child1Must()
						n2 := f.Child1Must().Child2Must()
						e2.addConj(n1, Negate(n2), e, "A4")
					}
					e.setHandled()
					break
				}

				if f.Child1Must().IsConjunction() {
					/*
						if !e.noConjLeft() {
							continue
						}
					*/
					for _, e2 := range eflat {
						if !e2.growthpoint() {
							continue
						}

						c1 := f.Child1Must().Child1Must()
						c2 := f.Child1Must().Child2Must()
						e2.addDisj(Negate(c1), Negate(c2), e, "A6")
					}
					e.setHandled()
					break
				}

			}

			if f.IsConjunction() {
				e.setHandled()
				for _, e2 := range eflat {
					if !e2.growthpoint() {
						continue
					}
					e2.addConj(f.Child1Must(), f.Child2Must(), e, "A2")
				}
				e.setHandled()
				break
			}

			if f.IsDisjunction() {
				/*
					if !n.normalized() {
						continue
					}

					if !n.noConjLeft() {
						continue
					}
				*/
				e.setHandled()
				for _, e2 := range eflat {
					if !e2.growthpoint() {
						continue
					}
					e2.addDisj(f.Child1Must(), f.Child2Must(), e, "A5")
				}
				//e.setHandled()
				break
			}

			if f.IsConditional() {
				if !n.normalized() {
					continue
				}
				e.setHandled()
				for _, e2 := range eflat {
					if !e2.growthpoint() {
						continue
					}
					e2.addDisj(Negate(f.Child1Must()), f.Child2Must(), e, "A7")
				}
				break
			}

		}
	}
}

func (n *Node) Instantiate(c string) *Node {

	if !n.IsQuantifier() {
		return n
	}

	return n.instantiate(n.BoundVariable(), c)
}

func instantiationSeries(n *Node) []string {

	type item struct {
		formula      string
		skIntro      string
		instantiated bool
	}

	var formulas []*item

	allConst := func(s []*item) []string {

		var r []string

		for _, e := range s {
			if e.skIntro != "" {
				r = append(r, e.skIntro)
			}
		}
		return r
	}

	more := func(s []*item) bool {

		for _, e := range s {

			if !e.instantiated {
				return true
			}
		}

		return false
	}

	//First round

	first := new(item)

	first.formula = n.String()

	formulas = append(formulas, first)

	for more(formulas) {

		for _, f := range formulas {

			if f.instantiated {
				continue
			}

			if Parse(f.formula).IsExistentialQ() {

				f.skIntro = nextSkolem()
				f.instantiated = true

				ni := new(item)
				ni.formula = Parse(f.formula).Instantiate(f.skIntro).String()
				if !Parse(ni.formula).IsQuantifier() {
					ni.instantiated = true
				}
				//				fmt.Println("X1 add ", ni.formula)
				formulas = append(formulas, ni)
				break
			}

			if Parse(f.formula).IsUniversalQ() {

				f.skIntro = nextSkolem()
				f.instantiated = true

				for _, cn := range allConst(formulas) {

					ni := new(item)
					ni.formula = Parse(f.formula).Instantiate(cn).String()
					if !Parse(ni.formula).IsQuantifier() {
						ni.instantiated = true
					}
					formulas = append(formulas, ni)
					//					fmt.Println("U1 add ", ni.formula)

				}
				break
			}
		}
	}

	i := 0
	for i = range formulas {
		if !Parse(formulas[i].formula).IsQuantifier() {
			formulas[i].instantiated = true
			continue
		}
		formulas[i].instantiated = false
		if Parse(formulas[i].formula).IsUniversalQ() {
			break
		}
	}

	for more(formulas[i:]) {

		for j, f := range formulas[i:] {
			if f.instantiated {
				continue
			}

			if Parse(f.formula).IsExistentialQ() {
				f.skIntro = nextSkolem()
				f.instantiated = true

				ni := new(item)
				ni.formula = Parse(f.formula).Instantiate(f.skIntro).String()
				if !Parse(ni.formula).IsQuantifier() {
					ni.instantiated = true
				}
				//				fmt.Println("X2 add ", ni.formula)
				formulas = append(formulas, ni)
				break
			}

			if Parse(f.formula).IsUniversalQ() {

				//f.skIntro = nextSkolem()
				f.instantiated = true

				for _, cn := range allConst(formulas[j+1:]) {

					ni := new(item)
					ni.formula = Parse(f.formula).Instantiate(cn).String()
					if !Parse(ni.formula).IsQuantifier() {
						ni.instantiated = true
					}
					//					fmt.Println("U2 add ", ni.formula)
					formulas = append(formulas, ni)

				}
				break
			}
		}
	}

	var str []string

	for _, s := range formulas {
		str = append(str, s.formula)
	}
	fmt.Println("returning instantiations")
	return str
}
