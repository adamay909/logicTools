package gentzen

import (
	"log"
	"math"
	"sort"
)

//ColSpec is for specifying features of columns of
//a truth table
type ColSpec struct {
	formula string
	mc      string
	c1, c2  int
}

//Table holds the column specifications and truth
//values of each cell
type Table struct {
	tableSpec []ColSpec
	vals      [][]bool
}

//TTrow holds string value for each row of a truth table.
type TTrow []string

//TextTable holds text strings for each cell of a table
type TextTable struct {
	vals   []TTrow
	atomic int
}

//Vals returns the text values of each cell of t.
func (t *TextTable) Vals() []TTrow {
	return t.vals
}

//ColSpecs returns the colspecs of t
func (t *Table) ColSpecs() []ColSpec {

	return t.tableSpec

}

//Vals returns truth values
func (t *Table) Vals() [][]bool {

	return t.vals

}

//SetColSpecs sets colspecs of t
func (t *Table) SetColSpecs(s []ColSpec) {
	t.tableSpec = s
	return
}

//SetVals sets t values
func (t *Table) SetVals(v [][]bool) {
	t.vals = v
	return
}

//Formula returns the formula
func (c *ColSpec) Formula() string {
	return c.formula
}

//SetFormula sets formula
func (c *ColSpec) SetFormula(s string) {
	c.formula = s
}

//MainConnective returns the main connective
func (c *ColSpec) MainConnective() string {
	return c.mc
}

//SetMainConnective sets connective
func (c *ColSpec) SetMainConnective(s string) {
	c.mc = s
}

//RefCols returns the columns referred to
func (c *ColSpec) RefCols() (int, int) {
	return c.c1, c.c2
}

//SetRefCols sets refcols
func (c *ColSpec) SetRefCols(i, j int) {
	c.c1 = i
	c.c2 = j
	return
}

//MkTable creates Table for s
func MkTable(s string) (table Table) {

	table.tableSpec = genTableSpec(getColumns(s))
	table.vals = genTable(table.tableSpec)

	return

}

//MkTextTable creates a table of strings out of t
func MkTextTable(table Table) TextTable {

	var t TextTable

	var r TTrow

	t.atomic = getNumberAtomicSentences(table.ColSpecs())

	for _, f := range table.ColSpecs() {
		r = append(r, Parse(f.Formula()).String())
	}

	t.vals = append(t.vals, r)

	cs := len(r)

	rs := len(table.Vals()[0])

	for i := 0; i < rs; i++ {
		r = nil
		for j := 0; j < cs; j++ {
			r = append(r, textOf(table.Vals()[j][i]))
		}
		t.vals = append(t.vals, r)
	}

	return t

}

//PrintLatexTable prints table as Latex table. rowSep forces
//printing visible row separators
func PrintLatexTable(table TextTable, rowSep bool) string {

	out := `%generated by gentzen` + "\n"

	out = out + `\begin{tabular}{`

	for i := 0; i < len(table.vals[0]); i++ {
		out = out + `c`
		if i < table.atomic-1 {
			continue
		}

		if i > table.atomic-2 && i < len(table.vals[0])-1 {
			out = out + `|`
		}

		if i == len(table.vals[0])-2 {
			out = out + `|`
		}
	}

	out = out + "}" + "\n"

	r := table.vals[0]
	for i, txt := range r {
		out = out + `\p{` + Parse(txt).StringLatex() + `}`
		if i != len(r)-1 {
			out = out + ` & `
		}
	}

	out = out + `\\` + "\n"
	out = out + `\hline` + "\n"

	for i := 1; i < len(table.vals); i++ {

		r := table.vals[i]

		for j, txt := range r {
			out = out + `\emph{` + txt + `}`
			if j != len(r)-1 {
				out = out + ` & `
			}
		}

		out = out + `\\` + "\n"
		if rowSep {
			out = out + `\hdashline` + "\n"
		}
	}
	out = out + `\end{tabular}` + "\n\n"

	return out

}

func textOf(v bool) string {
	if v {
		return "T"
	}
	return "F"
}

func tvalue(v1, v2 bool, mainConnective string) bool {

	switch mainConnective {

	case neg.String():
		return !v1

	case conj.String():
		return v1 && v2

	case disj.String():
		return v1 || v2

	case cond.String():
		return !v1 || v2

	default:
		log.Fatal("invalid main connective")
	}

	return false
}

//valuations creates table of valuations for n atomic sentences
func valuations(n int) (table [][]bool) {

	rows := int(math.Pow(2, float64(n)))
	for i := 0; i < n; i++ {
		var col []bool

		repeats := int(math.Pow(2, float64(i)))
		v := false
		for j := 0; j < rows; j = j + repeats {

			for k := 0; k < repeats; k++ {
				col = append(col, !v)

			}
			v = !v
		}
		table = append(table, col)
	}
	return table
}

//type tableSpec []colSpec

func getNumberAtomicSentences(cols []ColSpec) (n int) {

	n = 0

	for _, col := range cols {
		if col.mc != "" {
			break
		}
		n++
	}
	return n
}

func genTable(cols []ColSpec) (vals [][]bool) {

	nA := getNumberAtomicSentences(cols)
	vals = valuations(nA)

	for _, col := range cols[nA:] {
		var ncol []bool
		for i := 0; i < len(vals[0]); i++ {
			ncol = append(ncol, tvalue(vals[col.c1-1][i], vals[col.c2-1][i], col.mc))
		}
		vals = append(vals, ncol)
	}

	return vals

}

//printEmptyTable outputs LaTeX fragment for truth table
//specified by cols
func printEmptyTable(table Table) (out string) {

	cols := table.tableSpec
	vals := genTable(cols)

	out = out + `\begin{tabular}{`

	for i := 0; i < len(cols); i++ {
		out = out + `c`
		if i < getNumberAtomicSentences(cols)-1 {
			continue
		}

		if i > getNumberAtomicSentences(cols)-2 && i < len(cols)-1 {
			out = out + `|`
		}

		if i == len(cols)-2 {
			out = out + `|`
		}
	}

	out = out + "}" + "\n"

	for i := range cols {

		out = out + `\p{` + Parse(cols[i].formula).StringLatex() + `}`
		if i != len(cols)-1 {
			out = out + ` & `
		}

	}
	out = out + `\\` + "\n"
	out = out + `\hline` + "\n"

	for row := 0; row < len(vals[0]); row++ { //rows
		col := 0
		for ; col < getNumberAtomicSentences(cols); col++ { //columns for atomic

			if vals[col][row] == true {
				out = out + `\emph{T}`
			} else {
				out = out + `\emph{F}`
			}
			if col != len(vals)-1 {
				out = out + ` & `
			}
		}

		for ; col < len(cols); col++ { //columns for atomic

			out = out + "\t"
			if col != len(cols)-1 {
				out = out + ` & `
			}
		}
		out = out + "\t" + `\\` + "\n" + `\hdashline` + "\n"
	}
	out = out + `\end{tabular}` + "\n\n"

	return out

}

//printTable outputs LaTeX fragment for truth table
//specified by cols
func printTable(table Table) (out string) {

	cols := table.tableSpec
	vals := genTable(cols)

	out = out + `\begin{tabular}{`

	for i := 0; i < len(cols); i++ {
		out = out + `c`
		if i < getNumberAtomicSentences(cols)-1 {
			continue
		}

		if i > getNumberAtomicSentences(cols)-2 && i < len(cols)-1 {
			out = out + `|`
		}

		if i == len(cols)-2 {
			out = out + `|`
		}
	}

	out = out + "}" + "\n"

	for i := range cols {

		out = out + `\p{` + Parse(cols[i].formula).StringLatex() + `}`
		if i != len(cols)-1 {
			out = out + ` & `
		}

	}
	out = out + `\\` + "\n"
	out = out + `\hline` + "\n"

	for row := 0; row < len(vals[0]); row++ { //rows

		for col := 0; col < len(vals); col++ { //columns

			if vals[col][row] == true {
				out = out + `\emph{T}`
			} else {
				out = out + `\emph{F}`
			}
			if col != len(vals)-1 {
				out = out + ` & `
			}
		}
		out = out + `\\` + "\n"
	}
	out = out + `\end{tabular}` + "\n\n"

	return out

}

func isConnective(s string) bool {

	switch logicalConstant(s) {
	case neg:
		return true
	case conj:
		return true
	case disj:
		return true
	case cond:
		return true
	case uni:
		return true
	case ex:
		return true
	default:
		return false
	}
	return false
}

func listSentences(nodes []*Node) []string {

	var l []string

	for _, n := range nodes {
		l = append(l, n.String())
	}

	return l
}

func _removeDuplicates(old []string) []string {

	var l []string

	if len(old) == 0 {
		return old
	}

	l = append(l, old[0])

	for i := 1; i < len(old); i++ {
		if slicesContains(l, old[i]) {
			continue
		}
		l = append(l, old[i])
	}

	return l
}

func reorderSentences(l []string) []string {

	var ret []string

	sort.SliceStable(l, func(i, j int) bool { return Parse(l[i]).Class() < Parse(l[j]).Class() })

	max := Parse(l[len(l)-1]).Class()

	for class := 1; class <= max; class++ {
		var at []string
		for _, e := range l {
			if Parse(e).Class() == class {
				at = append(at, e)
			}
		}
		sort.Strings(at)
		ret = append(ret, at...)
	}

	return ret
}

func genTableSpec(s []string) []ColSpec {

	var ts []ColSpec

	for i := range s {
		var col ColSpec
		n := Parse(s[i])
		if n.IsAtomic() {
			col.formula = n.String()
			col.mc = ""
			col.c1 = i
			col.c2 = i
			ts = append(ts, col)
			continue
		}

		col.formula = n.String()
		s1 := n.subnode1.String()
		for j := range ts {
			if ts[j].formula == s1 {
				col.c1 = j + 1
				col.c2 = j + 1
			}
		}
		if n.MainConnective() != neg {
			s2 := n.subnode2.String()
			for j := range ts {
				if ts[j].formula == s2 {
					col.c2 = j + 1
				}
			}
		}
		col.mc = n.MainConnective().String()
		ts = append(ts, col)
	}

	return ts
}

func getColumns(s string) []string {

	n, err := ParseStrict(s)

	if err != nil {
		log.Fatal("malformed: ", s)
	}

	nodes := getSubnodes(n)

	l := listSentences(nodes)

	l = slicesCleanDuplicates(l)

	l = reorderSentences(l)
	//
	return l
}
