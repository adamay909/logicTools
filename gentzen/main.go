package gentzen

import (
	"log"
	"strconv"
)

var (
	oPL   = false
	oTHM  = false
	oCOND = true
)

func init() {

	connectives = append(connectivesSL, connectivesPL...)
	logger = log.New(&checkLog, "", 0)

}

//ShowLog displays log. Currently, logging is only done by proof checker.
func ShowLog() string {

	return checkLog.String()

}

//ClearLog clears log.
func ClearLog() {
	checkLog.Reset()
	return
}

//WriteLog writes s to log.
func WriteLog(s string, p string) {
	logger.SetPrefix(p)
	logger.Print(s)
	return
}

//SetConditional determines whether we use the conditional.
func SetConditional(v bool) {
	oCOND = v
	if oCOND {
		connectivesSL = [][]string{
			{string(neg), `\lnot `, `\neg `, "\u00ac"},
			{string(conj), `\land `, `\wedge `, "\u2227"},
			{string(disj), `\lor `, `\vee `, "\u2228"},
			{string(cond), `\limplies `, `\supset `, "\u2283"},
		}
	} else {
		connectivesSL = [][]string{
			{string(neg), `\lnot `, `\neg `, "\u00ac"},
			{string(conj), `\land `, `\wedge `, "\u2227"},
			{string(disj), `\lor `, `\vee `, "\u2228"},
		}
	}
	connectives = append(connectivesSL, connectivesPL...)
	return
}

//SetPL enables Predicate Logic Processing when v is true.
//By default, PL processing is disabled.
func SetPL(v bool) {

	oPL = v

}

//SetAllowTheorems sets whether appeal to some standard theorems
//is allowed. Default is false.
func SetAllowTheorems(v bool) {
	oTHM = v
}

//SetStrict sets whether inferece rules should be checked strictly.
func SetStrict(v bool) {
	StrictCheck = v
}

/*
CheckDeriv checks the derivation given by lines.
Each line represents a sequent followed by an annotation
consisting of line references and inference rule/theorem name.
The elements of each line must be semicolon separated. You may use
spaces and tabs for readability. The available rules are:

ne: negation elimination

ni: negation introduction

de: disjunction elimination

di: disjunction introduction

ke: conjunction elimination

ki: conjunction introduction

ce: conditional elimination

ci: conditional introduction

ue: universal quantifier elimination

ui: universal quantifier introduction

ei: existential quantifier introduction

ee: existential quantifier elimination


see the textbook on how the rules work.
*/
func CheckDeriv(lines []string, offset int) bool {

	return checkDerivation(lines, offset)

}

//GenTruthTable prints truth table for s. Obsolete. use
//MkTable and MkTextTable instead.
func GenTruthTable(s string) string {

	//return printTable(genTableSpec(getColumns(s)))
	return printTable(MkTable(s))
}

//GenEmptyTruthTable prints an empty truth table for s.
//Obsolete. Use functionality provided by TextTable type instead.
func GenEmptyTruthTable(s string) string {

	//	return printEmptyTable(genTableSpec(getColumns(s)))
	return printEmptyTable(MkTable(s))

}

//GenTruthTableValues generates the truth values for
//each cell of columns. Obsolete. Use functionality provided
//by Table type instead.
func GenTruthTableValues(s string) [][]bool {

	return MkTable(s).vals
	//genTable(genTableSpec(getColumns(s)))
}

//IsTautology returns whether s is a tautology.
func IsTautology(s string) bool {

	t := MkTable(s).vals
	//genTable(genTableSpec(getColumns(s)))

	lc := t[len(t)-1]

	for _, v := range lc {
		if !v {
			return false
		}
	}
	return true
}

//IsWff returns whether s is a wff.
func IsWff(s string) bool {

	_, err := ParseStrict(s)

	return err == nil

}

//PrintDeriv prints the derivation given by lines
//as latex formatted derivation.
func PrintDeriv(lines []string, offset int) (out string) {
	seq1, err := parseArgline(lines[0])
	seq2, err := parseArgline(lines[len(lines)-1])

	if err == nil {
		if seq2.seq.datum == "" {
			out = out + `%Prove \p{` + seq2.seq.StringLatex() + "}\n\n"
		} else {
			out = out + `%Derive from \p{` + seq1.seq.StringLatex() + `} to \p{` + seq2.seq.StringLatex() + "}\n\n"
		}
	}
	out = out + `\begin{argumentN}[` + strconv.Itoa(offset) + "]\n"

	out = out + `%generated by gentzen` + "\n\n"

	for i := range lines {

		out = out + printArgLine(lines[i])
	}

	out = out + `\end{argumentN}` + "\n\n"

	return out
}

//RandomSentence returns a randomly generated sentence of
//sentential logic with at most m atomic sentences (m is capped at 10).
//d specified max depth of recursion which determined the max number of
//connectives. It used the package math/rand and you need to seed
//the PRNG yourself.
func RandomSentence(m, d int) string {

	return genRand(m, d)

}

//Parse should only be used when s is known to be well-formed.
func Parse(s string) *Node {

	n, err := ParseStrict(s)

	if err != nil {
		log.Fatal("malformed formula: ", s, err.Error())
	}
	return n
}

//ParseStrict parses s.
func ParseStrict(s string) (n *Node, err error) {
	tokens, err := tokenize(s)
	if err != nil {
		return n, err
	}
	return parseTokens(tokens)
}
