package gentzen

type tablNode struct {
	tstr    tokenStr
	child   []*tablNode
	parent  *tablNode
	closed  bool
	visited bool
}

func (n *tablNode) top() *tablNode {

	for e := n; e != nil; e = e.parent {
		if e.parent == nil {
			return e
		}
	}
	return n
}

func (n *tablNode) linearize() []*tablNode {

	var resp []*tablNode

	var walk func(*tablNode)

	walk = func(e *tablNode) {

		resp = append(resp, e)

		for _, c := range e.child {

			walk(c)

		}

	}

	walk(n)

	return resp

}

func (n *tablNode) growTable() {

	if n.closed {
		return
	}

	if n.visited {
		return
	}

	n.visited = true

	var n0, n1 *tablNode

	subs := n.tstr.subFormulas()

	n0 = new(tablNode)
	n0.tstr = subs[0]

	if len(subs) == 2 {
		n1 = new(tablNode)
		n1.tstr = subs[1]
	}

	switch n.tstr[0].tokenType {

	case tConj:

		if len(n1.tstr) > len(n0.tstr) {
			n.addChild(n1)
			n1.addChild(n0)
		} else {
			n.addChild(n0)
			n0.addChild(n1)
		}

	case tDisj:

		n.addChild(n0)
		n.addChild(n1)

	case tCond:

		n0.tstr = n.tstr.negate()

		n.addChild(n0)
		n.addChild(n1)

	case tNeg:

		switch n.tstr[1].tokenType {

		case tNeg:

			n2 := new(tablNode)
			n2.tstr = append(n2.tstr, n.tstr[2:]...)
			n.addChild(n2)

			//NKpq => ANpNq
		case tConj:

			subs2 := n0.tstr.subFormulas()

			n2 := new(tablNode)
			n2.tstr = subs2[0].negate()

			n3 := new(tablNode)
			n3.tstr = subs2[1].negate()

			n.addChild(n2)
			n.addChild(n3)

			//NApq => KNpNq
		case tDisj:

			subs2 := n0.tstr.subFormulas()

			n2 := new(tablNode)
			n2.tstr = subs2[0].negate()

			n3 := new(tablNode)
			n3.tstr = subs2[1].negate()

			if len(n3.tstr) > len(n2.tstr) {
				n.addChild(n3)
				n3.addChild(n2)
			} else {
				n.addChild(n2)
				n2.addChild(n3)
			}

			//NCpq =>KpNq
		case tCond:
			subs2 := n0.tstr.subFormulas()

			n2 := new(tablNode)
			n2.tstr = subs2[0]

			n3 := new(tablNode)
			n3.tstr = subs2[1].negate()

			n.addChild(n2)
			n2.addChild(n3)
		}

	default:
		n.closd = true
	}
}

func (tk tokenStr) negate() (tkn tokenStr) {

	tkn = append(tkn, token{tokenType: tNeg, str: "N"})

	tkn = append(tkn, tk...)

	return
}

func (tk tokenStr) disjoin(tk2 tokenStr) tokenStr {

	tkn = append(tkn, token{tokenType: tDisj, str: "A"})

	tkn = append(tkn, tk...)

	tkn = append(tkn, tk2...)

	return

}

func (tk tokenStr) conjoin(tk2 tokenStr) tokenStr {

	tkn = append(tkn, token{tokenType: tConj, str: "K"})

	tkn = append(tkn, tk...)

	tkn = append(tkn, tk2...)

	return

}

func (n *tablNode) addChild(c *tablNode) {

	n.child = append(n.child, c)

	c.parent = n

}
